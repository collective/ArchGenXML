"""
Very simple module for extracting classes and method/function codes
out of a python file
"""
import parser
import pprint
import sys
import types

PROTECTED_BEGIN = '##code-section'
PROTECTED_END = '##/code-section'

class PyModule:
    """ This is the module being called directly from the rest of ArchGenXML

    Through the __init__() you can feed it a file and it chops it up
    in neat chunks of classes and methods. This way the other parts of
    ArchGenXML can add/remove/augment those chunks.
    """
    filebuf = None
    splittedSource = None
    ast = None
    code = None
    src = None
    classes = {}
    functions = {}
    protectedSections = {}

    def __init__(self, file, mode='file'):
        """ Start dividing 'file' in chunks

        'file' is the to chunk up. By default it is the name of a file
        on the filesystem, but with 'mode' set to 'string', 'file' is
        passed as a string.
        """
        # Dictionary inits
        self.classes = {}
        self.functions = {}
        self.protectedSections = {}
        # Read and mangle the file
        self.filebuf = self.readFile(file, mode)
        self.splittedSource = self.filebuf.split('\n')
        # Note: ast = abstract syntax tree (python internal thingy),
        # generated by the imported 'parser'.
        self.ast = parser.suite(self.filebuf)
        self.code = self.ast.compile()
        # The next two filter out the classes and the top-level
        # functions in the sourcefile and the protected
        # sections. Beware that the rest is left out!
        self.findClassesAndFunctions()
        self.findProtectedSections()

    def readFile(self, file, mode='file'):
        """ Read the file into a string

        File can be a filename, a file object or a big string.
        """
        if type(file) in (type(''), type(u'')):
            # filename or big string
            if mode == 'string':
                # Big string!
                result = file
            else:
                # Filename!
                result = open(file).read()
        else:
            # File object!
            result = file.read()
        return result

    def findClassesAndFunctions(self):
        """ Collect code elements in the source file

        Code elements are seperate things like functions and classes,
        the import-statements, local variables etcetera are not code
        elements filtered out by this method.

        The results are placed in self.classes and
        self.functions. Functions are the top-level methods, methods
        reside inside the classes.
        """
        # First get all the code elements as seen by the python parser
        codes = [c for c in self.code.co_consts if type(c) ==
                 types.CodeType]
        # Get the classes
        classes = [c for c in codes if self.isItAClass(c)]
        for c in classes:
            klass = PyClass(c, self)
            self.classes[c.co_name] = klass
        # Get the functions
        functions = [c for c in codes if self.isItAFunction(c)]
        for f in functions:
            func = PyFunction(f, self)
            self.functions[f.co_name] = func

    def findProtectedSections(self):
        """ Find the protected sections in the source file

        The results are placed in self.protectedSections, which is a
        dictionary. The keys are the names of the protected sections
        (like 'module-header').
        """
        for i in xrange(0, len(self.splittedSource)):
            line = self.splittedSource[i]
            sline = line.strip()
            if sline.startswith(PROTECTED_BEGIN):
                j = start = i
                sectionname = sline.split()[1]
                try:
                    while not self.splittedSource[j].strip().startswith(PROTECTED_END): 
                        j = j+1
                except IndexError:
                    return
                end = j
                protectedSection = '\n'.join(self.splittedSource[start+1:end])
                self.protectedSections[sectionname] = protectedSection

    def isItAClass(self, c):
        """ Woooh - heuristic method to check if a code fragment is a class
        """
        fl = c.co_firstlineno
        if self.splittedSource[fl-1].strip().startswith('class'):
            return 1
        res = len([o for o in c.co_consts if type(o) == types.CodeType])
        #print 'Class:####',c.co_name, res, c.co_consts
        return res

    def isItAFunction(self, c):
        """ Woooh - heuristic method to check if a code fragment is a
        function
        """
        fl = c.co_firstlineno
        if self.splittedSource[fl-1].startswith('def'):
            return 1

    def getProtectedSection(self, section):
        return self.protectedSections.get(section)

    def printit(self):
        print 'PyModule:'

        print '========'
        print 'CLASSES'
        print '========'
        for c in self.classes.values():
            c.printit()

        print '========'
        print 'FUNCTIONS'
        print '========'
        for f in self.functions.values():
            f.printit()

        print '========'
        print 'PROTECTED SECTIONS'
        print '========'
        for k, v in self.protectedSections.items():
            print 'section:', k
            print '-----------'
            print v
            print '-----------'


class PyCodeElement:
    module = None
    code = None
    src = None

    def __init__(self, code, module):
        self.code = code
        self.module = module
        
    def getSrc(self):
        return self.src
    
    def getName(self):
        return self.name


class PyFunction(PyCodeElement):
    typename='function'
    def __init__(self, code, module):
        PyCodeElement.__init__(self, code, module)
        self.buildMethod()

    def buildMethod(self):
        """ Prepare the method for subsequent inclusion in the
        generated class
        """
        self.name = self.code.co_name
        self.start = self.code.co_firstlineno - 1
        self.src = self.extractCode()

    def printit(self):
        print '%s:' % self.typename, self.code.co_name
        print '-------------------------------------------------------'
        print self.src
        print '-------------------------------------------------------'

    def getProtectedSection(self, section):
        return self.module.getProtectedSection(section)

    def codeLength(self):
        """ Calculate the length of a method using the code.co_lnotab
        """
        res=0
        for i in range(0, len(self.code.co_lnotab),2):
            cl = ord(self.code.co_lnotab[i+1])
            # I don't know what that next test does
            if cl != 255:
                res += cl
        return res+1

    def extractCode(self):
        """ Return '\n'-string containing the method code
        """
        snip = []
        length = self.codeLength()
        start = self.start
        codelist = self.module.splittedSource
        # and now take into account the trailing backslashes
        while (codelist[start+length].strip() and 
               codelist[start+length].strip()[-1] == '\\'):
            length += 1
        snip = codelist[start:start+length+1]
        return '\n'.join(snip)

        
class PyMethod(PyFunction):
    typename = 'method'
        

class PyClass(PyCodeElement):
    methods = {}
    module = None
    typename = 'Class'
    
    def __init__(self, code, module):
        PyCodeElement.__init__(self, code, module)
        self.methods = {}
        self.name = code.co_name
        self.module = module
        #print 'Class:', self.name
        self.buildMethods()
        
    def buildMethods(self):
        meths = [o for o in self.code.co_consts if type(o) == types.CodeType]
        for m in meths:
            name = m.co_name
            self.methods[name] = PyMethod(m, self.module)

    def printit(self):
        print '======================================='
        print self.typename, ':', self.name
        print '======================================='
        for m in self.methods.values():
            m.printit()
            
    def getProtectedSection(self, section):
        return self.module.getProtectedSection(section)
    
    def getMethodNames(self):
        return self.methods.keys()


if __name__=='__main__':
    mod = PyModule(sys.argv[1])
    mod.printit()
   
